# Урок 12. Управление конфиденциальными данными

- [Определение секретов в compose.yml](#определение-секретов-в-composeyml)
- [Доступ к секретам во время сборки](#доступ-к-секретам-во-время-сборки)
  - [Файлы секретов](#файлы-секретов)
  - [Почему не стоит использовать переменные времени сборки?](#почему-не-стоит-использовать-переменные-времени-сборки)
  - [Доступ к SSH ключам во время сборки](#доступ-к-ssh-ключам-во-время-сборки)
  - [Сборка проекта с секретами в Docker Compose](#сборка-проекта-с-секретами-в-docker-compose)
- [Пример вспомогательного образа](#пример-вспомогательного-образа)
- [Ссылки](#ссылки)

## Определение секретов в compose.yml

Веб приложение на PHP и MongoDB, которое ведет журнал посещаемости сайта.
Для каждого клиента в журнал записывается его IP адрес, браузер и время визита.

Имя пользователя и пароль для подключения к БД - это конфиденциальные данные.

```shell
# Сборка проекта
./bin/build.sh

# Запуск проекта
docker compose up -d

# Проверка работоспособности
curl 127.0.0.1
```

## Доступ к секретам во время сборки

### Файлы секретов

При сборке образа необходимо установить Python пакет из частного реестра.
Для доступа к реестру нужно знать имя пользователя и пароль - это конфиденциальные данные.

```shell
# Генерация файла htpasswd с пользователем user и паролем test
docker run --rm -ti httpd:2.4-alpine3.19 htpasswd -nb user test > ./pypi-server/secrets/pypi_htpasswd

# Запуск частного реестра
docker compose --project-directory ./pypi-server up -d


# Генерация файла-секрета для аргумента indexurl
echo "http://user:test@$(hostname -I | awk '/^192/ {print $1}'):8080" > ./example-project/secrets/indexurl

# Сборка образа с указанием файла-секрета
docker build -t example-mount-secret \
    --secret id=indexurl,src=./example-project/secrets/indexurl \
    ./example-project/src/run-mount-secret

# Проверка установленного пакета
docker run --rm example-mount-secret pip freeze | grep kirill-vercetti
```

### Почему не стоит использовать переменные времени сборки?

1. Переменные времени сборки передаются на этапе сборки образа Docker и могут быть включены в слои образа.
   Даже если переменные не видны непосредственно в итоговом образе/запущенном контейнере,
   они могут быть восстановлены из промежуточных слоев образа.

1. Docker хранит историю изменений каждого слоя образа, включая команды сборки и использованные переменные.
   С помощью команды `docker history` можно увидеть, какие переменные использовались на этапе сборки.

1. Переменные времени сборки могут быть сохранены в кеше сборки,
   что приводит к потенциальной утечке конфиденциальных данных при последующих сборках, если кеш не был сброшен.

1. Переменные времени сборки могут попасть в лог-файлы, в историю команд или в стандартный поток вывода,
   что делает их доступными для других пользователей системы.

### Доступ к SSH ключам во время сборки

При сборке образа вам может потребоваться клонировать приватные репозитории.
С помощью аргумента `--ssh` команды `docker build` можно передать SSH ключи,
чтобы Docker мог аутентифицироваться и получить доступ к этим репозиториям.

Другой пример, с помощью NPM установить пакет из приватные Git репозитория, используя SSH ключ.

SSH ключи - это конфиденциальные данные, копировать их в образ опасно.
Можно временно предоставить доступ к ключам через SSH-агент.
Это уменьшает риск утечки ключей.

С помощью аргумента `--ssh` можно указать местоположение локального сокета SSH-агента
или закрытых ключей, которые будут доступны для сборки.

Если путь не указан, то используется значение переменной окружения `$SSH_AUTH_SOCK`.
Чтобы сработала конфигурация по умолчанию, нужно добавить свои ключи в локальный SSH-агент.
С помощью команды `ssh-add -L` вы можете посмотреть список добавленных ключей.

Если вы не хотите использовать SSH-агент, можно явно указать путь к приватному ключу `--ssh default=$HOME/.ssh/id_rsa`.
Здесь используется приватный ключ из домашней директории текущего пользователя с именем `id_rsa`.

```shell
# Сборка образа
docker build -t example-mount-ssh \
    --ssh=default=$HOME/.ssh/id_rsa \
    ./example-project/src/run-mount-ssh

# Проверка установленного пакета
docker run --rm example-mount-ssh npm list | grep kirill-vercetti
```

### Сборка проекта с секретами в Docker Compose

```shell
# Сборка проекта
docker compose --project-directory ./example-project build

# Проверка установленных пакетов
docker compose --project-directory ./example-project run --rm python_app \
    pip freeze | grep kirill-vercetti
docker compose --project-directory ./example-project run --rm node_app \
    npm list | grep kirill-vercetti
```

## Пример вспомогательного образа

Я придумал распространять повторно используемые скрипты и Shell функции между образами,
используя промежуточный или [вспомогательный образ](https://hub.docker.com/r/kyzimaspb/useful).
Этот образ создан на базе `scratch`, а нужные скрипты или библиотеки функций в конечный образ
можно добавить с помощью инструкции `COPY --from=kyzimaspb/useful`.

В этом способе нет дублирования скриптов и функций в образах,
нет необходимости размещать их на публичном веб сервере и скачивать в образ с помощью `ADD`,
в конечном образе будет добавлен только один слой независимо от количества нужных скриптов и функций.

В примере в образ будет скопировано два скрипта `compver.sh` и `switch-user.sh` и одна библиотека функций `secrets.sh`:

```dockerfile
# Копируем из вспомогательного образа
# все необходимые библиотеки и скрипты/программы
COPY --from=kyzimaspb/useful \
    /apps/compver/compver.sh
    /apps/switch-user/switch-user.sh \
    /apps/secrets/secrets.sh \
    /usr/local/bin/
```

В абстрактном примере `secret-entrypoint` демонстрируется использование пользовательской входной точки
и как сохранить функциональность родительской входной точки, если она существует.

Для подключения к серверу MongoDB приложению требуется передать данные доступа.
Через переменные окружения `MONGO_HOST`, `MONGO_USERNAME`, `MONGO_PASSWORD` и `MONGO_DATABASE` можно передать данные в открытом виде.
Для любой переменной можно добавить суффикс `_FILE` и передавать данные через Docker-секреты.
Переменные `MONGO_USERNAME`, `MONGO_PASSWORD` и `MONGO_DATABASE` обязательные - если их не передать, контейнер завершит работу с ошибкой.
Это результат работы функции `fileEnv` из библиотеки `secrets.sh`.
А вот переменная `MONGO_HOST` имеет значение по умолчанию `mongo` и не является обязательной:

```shell
# Сборка образа
docker build -t example-secrets -f Dockerfile ./root

# Запуск контейнера завершится ошибкой из-за обязательных переменных окружения
docker run --rm -ti --name secret_1 -p "80:80" example-secrets
```

С помощью скрипта `compver.sh` выполняется проверка минимальной версии PHP.
Если версия ниже `8.0` - контейнер завершит работу с ошибкой.
В реальном образе такая проверка лишена смысла,
потому что вы сами контролируете какую версию PHP выбрать для сборки конечного образа.
Но если вы создаете универсальный образ для запуска какой-либо программы,
и даете возможность с помощью аргументов сборки указать версию этой программы,
то чтобы пользователь образа не столкнулся с ошибками,
вы можете проверить запрошенную версию и запретить сборку или запуск контейнера.
Другая ситуация, вам нужна совместимость с разными версиями языка программирования, фреймворка или запускаемой программы,
вы можете проверить текущую версию и в процессе сборки или в запущенном контейнере подготовить необходимое окружение:

```shell
# Сборка образа с очень старой версией PHP
docker build \
   -t example-secrets \
   -f Dockerfile \
   --build-arg PHP_VERSION=5.6-apache \
   ./root

# Запуск контейнера завершится ошибкой из-за проверки на версию PHP
docker run --rm -ti --name secret_1 \
   -e MONGO_HOST=mongo \
   -e MONGO_USERNAME=user \
   -e MONGO_PASSWORD=123 \
   -e MONGO_DATABASE=demo \
   -p "80:80" \
   example-secrets
```

## Ссылки
