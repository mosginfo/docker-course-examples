# Урок 12. Управление конфиденциальными данными

- [Определение секретов в compose.yml](#определение-секретов-в-composeyml)
- [Доступ к секретам во время сборки](#доступ-к-секретам-во-время-сборки)
  - [Монтирование файлов секретов во время сборки](#файлы-секретов)
  - [Почему не стоит использовать переменные времени сборки?](#почему-не-стоит-использовать-переменные-времени-сборки)
  - [Доступ к SSH ключам во время сборки](#доступ-к-ssh-ключам-во-время-сборки)
  - [Сборка проекта с секретами в Docker Compose](#сборка-проекта-с-секретами-в-docker-compose)
- [Комментарии к уроку](#комментарии-к-уроку)
  - [Образ pypiserver/pypiserver](#образ-pypiserverpypiserver)
  - [PHP функция getConfig](#php-функция-getconfig)
  - [Примеры пакетов](#примеры-пакетов)
- [Пример вспомогательного образа](#пример-вспомогательного-образа)
- [Ссылки](#ссылки)

## Определение секретов в compose.yml

Веб приложение на PHP и MongoDB, которое ведет журнал посещаемости сайта.
Для каждого клиента в журнал записывается его IP адрес, браузер и время визита.

Имя пользователя и пароль для подключения к БД - это конфиденциальные данные.

```shell
# Сборка проекта
./bin/build.sh

# Запуск проекта
docker compose up -d

# Проверка работоспособности
curl 127.0.0.1
```

## Доступ к секретам во время сборки

### Файлы секретов

При сборке образа необходимо установить Python пакет из частного реестра.
Для доступа к реестру нужно знать имя пользователя и пароль - это конфиденциальные данные.

```shell
# Генерация файла htpasswd с пользователем user и паролем test
docker run --rm -ti httpd:2.4-alpine3.19 htpasswd -nb user test > ./pypi-server/secrets/pypi_htpasswd

# Запуск частного реестра
docker compose --project-directory ./pypi-server up -d


# Генерация файла-секрета для аргумента indexurl
echo "http://user:test@$(hostname -I | awk '/^192/ {print $1}'):8080" > ./example-project/secrets/indexurl

# Сборка образа с указанием файла-секрета
docker build -t example-mount-secret \
    --secret id=indexurl,src=./example-project/secrets/indexurl \
    ./example-project/src/run-mount-secret

# Проверка установленного пакета
docker run --rm example-mount-secret pip freeze | grep kirill-vercetti
```

### Почему не стоит использовать переменные времени сборки?

1. Переменные времени сборки передаются на этапе сборки образа Docker и могут быть включены в слои образа.
   Даже если переменные не видны непосредственно в итоговом образе/запущенном контейнере,
   они могут быть восстановлены из промежуточных слоев образа.

1. Docker хранит историю изменений каждого слоя образа, включая команды сборки и использованные переменные.
   С помощью команды `docker history` можно увидеть, какие переменные использовались на этапе сборки.

1. Переменные времени сборки могут быть сохранены в кеше сборки,
   что приводит к потенциальной утечке конфиденциальных данных при последующих сборках, если кеш не был сброшен.

1. Переменные времени сборки могут попасть в лог-файлы, в историю команд или в стандартный поток вывода,
   что делает их доступными для других пользователей системы.

### Доступ к SSH ключам во время сборки

При сборке образа вам может потребоваться клонировать приватные репозитории.
С помощью аргумента `--ssh` команды `docker build` можно передать SSH ключи,
чтобы Docker мог аутентифицироваться и получить доступ к этим репозиториям.

Другой пример, с помощью NPM установить пакет из приватного Git репозитория, используя SSH ключ.

SSH ключи - это конфиденциальные данные, копировать их в образ опасно.
Можно временно предоставить доступ к ключам через SSH-агент.
Это уменьшает риск утечки ключей.

С помощью аргумента `--ssh` можно указать местоположение локального сокета SSH-агента
или закрытых ключей, которые будут доступны для сборки.

Если путь не указан, то используется значение переменной окружения `$SSH_AUTH_SOCK`.
Чтобы сработала конфигурация по умолчанию, нужно добавить свои ключи в локальный SSH-агент.
С помощью команды `ssh-add -L` вы можете посмотреть список добавленных ключей.

Если вы не хотите использовать SSH-агент, можно явно указать путь к приватному ключу `--ssh default=$HOME/.ssh/id_rsa`.
Здесь используется приватный ключ из домашней директории текущего пользователя с именем `id_rsa`.

```shell
# Сборка образа
docker build -t example-mount-ssh \
    --ssh default=$HOME/.ssh/id_rsa \
    ./example-project/src/run-mount-ssh

# Проверка установленного пакета
docker run --rm example-mount-ssh npm list | grep kirill-vercetti
```

### Сборка проекта с секретами в Docker Compose

```shell
# Сборка проекта
docker compose --project-directory ./example-project build

# Проверка установленных пакетов
docker compose --project-directory ./example-project run --rm python_app \
    pip freeze | grep kirill-vercetti
docker compose --project-directory ./example-project run --rm node_app \
    npm list | grep kirill-vercetti
```

## Комментарии к уроку

### Образ pypiserver/pypiserver

Для частного реестра Python пакетов существует множество серверов.
Я выбрал данный сервер только потому, что его авторы уже создали Docker образ.
В уроке, для быстрого запуска сервера, мне этого достаточно.

Не могу сказать как этот сервер покажет себя в работе, но мне не понравились некоторые моменты.
Если у меня будет реальная задача поднять в производстве закрытый реестр Python пакетов,
я вряд ли выберу данный сервер из-за этих моментов. 

**Как его завернули в Docker образ**

Зачем на пользователя перекладывать создание `.htpasswd` файла?
Сервер написан на Python, в образе установлен пакет `passlib`.
С помощью этого пакета можно управлять этим файлом.
В частности, можно добавить нового пользователя.
Через переменные окружения можно передать имя и пароль для пользователя,
назовем его администратором в открытом виде или с помощью секретов,
по аналогии как это сделано в официальных образах для баз данных.

> Я не стал разбираться, есть ли разграничение прав доступа и можно ли добавить регистрацию

**Только установка пакетов по умолчанию**

С одной стороны, я могу это объяснить тем, что аутентификация по умолчанию отсутствует
и это своего рода защита. Но вопрос, как загрузить пакет на сервер?
Как я должен узнать о доступных для установки пакетах?
Почему если указан файл `.htpasswd` - автоматически не включаются все доступные действия?
Зачем тогда запускать сервер, если по умолчанию это "черная коробка"?
Имхо, нужно разрешать все действия без аутентификации - пользователь сам в ответе за свои действия.

**Частичная реализация API**

Из документации:
> **pypiserver** does not implement the full API as seen on [PyPI](https://pypi.org/).
> It implements just enough to make **easy_install**, **pip install**, and **search** work.

### PHP функция getConfig

Если вы работаете только с PHP, то нет проблем использовать функцию для чтения секретов,
написанную на PHP. Ее можно оформить в Composer пакет и распространять между проектами.

Обобщенно, если вы работаете только с одним языком программирования,
то можно написать функцию чтения секретов на этом языке.

Рекомендуется вызывать эту функцию в скрипте, указанном в инструкции `ENTRYPOINT`,
чтобы предотвратить запуск контейнера при отсутствии обязательных секретов.
Если приложение в контейнере способно самостоятельно прекратить запуск контейнера
при отсутствии обязательных секретов, то можно обойтись без `ENTRYPOINT`.

Если вы работаете с разными языками программирования
или нельзя вносить изменения в исходный код приложения,
то лучше реализовать эту функцию на языке сценариев оболочки.
[Пример такой функции из официального образа MySQL](https://github.com/docker-library/mysql/blob/a482468640c602ccd8a7c86a4c7422f18a307326/docker-entrypoint.sh#L28).

Существуют различия между оболочками Shell (`#!/usr/bin/env sh`), Bash (`#!/usr/bin/env bash`) и т.п.
В контейнерах на базе образа Alpine чаще всего используется Shell, а на базе Debian - Bash.
Если нужна поддержка обеих оболочек, то используйте синтаксис Shell.

Я взял за основу функцию `file_env` из образа MySQL, переписал ее с поддержкой Shell
и поменял логику чтения и возврата значения по умолчанию:
[исходный код моей функции](https://github.com/kyzima-spb/docker-useful/blob/8cbcf499b6af2662dece9ad43a084e3f906b5121/apps/secrets/secrets.sh#L72).
Чтобы не дублировать эту функцию в образах, я придумал способ распространения shell-скриптов
с использованием [вспомогательного образа](#пример-вспомогательного-образа).

Пример входной точки для рассмотренного приложения на PHP.
Рабочий абстрактный пример с использованием вспомогательного образа
можно найти в директории `secrets-entrypoint`:

```shell
#!/usr/bin/env sh

# Ваша реализация функции чтения секретов
fileEnv() {}

# Пересоздаем все указанные переменные окружения
# Любая переменная может быть передана как секрет с суффиксом _FILE в имени
# Все переменные, кроме MONGO_HOST, обязательные для указания
fileEnv 'MONGO_HOST' 'mongo'
fileEnv 'MONGO_USERNAME'
fileEnv 'MONGO_PASSWORD'
fileEnv 'MONGO_DATABASE'

# Выполняем "родительский" скрипт с переданными аргументами
exec docker-php-entrypoint "$@"
```

### Примеры пакетов

Пакеты, которые были установлены из закрытых источников, не делают ничего полезного, это пакеты пустышки.
Если вы хотите повторить примеры из урока, то исходники пакетов доступны в директории `example-packages`.
Убедительная просьба не загружать эти пакеты в публичные реестры, чтобы сохранить чистоту эксперимента =)

## Пример вспомогательного образа

Я придумал распространять повторно используемые скрипты и Shell функции между образами,
используя промежуточный или [вспомогательный образ](https://hub.docker.com/r/kyzimaspb/useful).
Этот образ создан на базе `scratch`, а нужные скрипты или библиотеки функций в конечный образ
можно добавить с помощью инструкции `COPY --from=kyzimaspb/useful`.

В этом способе нет дублирования скриптов и функций в образах,
нет необходимости размещать их на публичном веб сервере и скачивать в образ с помощью `ADD`,
в конечном образе будет добавлен только один слой независимо от количества нужных скриптов и функций.

В примере в образ будет скопировано два скрипта `compver.sh` и `switch-user.sh` и одна библиотека функций `secrets.sh`:

```dockerfile
# Копируем из вспомогательного образа
# все необходимые библиотеки и скрипты/программы
COPY --from=kyzimaspb/useful \
    /apps/compver/compver.sh
    /apps/switch-user/switch-user.sh \
    /apps/secrets/secrets.sh \
    /usr/local/bin/
```

В абстрактном примере `secret-entrypoint` демонстрируется использование пользовательской входной точки
и как сохранить функциональность родительской входной точки, если она существует.

Для подключения к серверу MongoDB приложению требуется передать данные доступа.
Через переменные окружения `MONGO_HOST`, `MONGO_USERNAME`, `MONGO_PASSWORD` и `MONGO_DATABASE` можно передать данные в открытом виде.
Для любой переменной можно добавить суффикс `_FILE` и передавать данные через Docker-секреты.
Переменные `MONGO_USERNAME`, `MONGO_PASSWORD` и `MONGO_DATABASE` обязательные - если их не передать, контейнер завершит работу с ошибкой.
Это результат работы функции `fileEnv` из библиотеки `secrets.sh`.
А вот переменная `MONGO_HOST` имеет значение по умолчанию `mongo` и не является обязательной:

```shell
# Сборка образа
docker build -t example-secrets -f Dockerfile ./root

# Запуск контейнера завершится ошибкой из-за обязательных переменных окружения
docker run --rm -ti --name secret_1 -p "80:80" example-secrets
```

С помощью скрипта `compver.sh` выполняется проверка минимальной версии PHP.
Если версия ниже `8.0` - контейнер завершит работу с ошибкой.
В реальном образе такая проверка лишена смысла,
потому что вы сами контролируете какую версию PHP выбрать для сборки конечного образа.
Но если вы создаете универсальный образ для запуска какой-либо программы,
и даете возможность с помощью аргументов сборки указать версию этой программы,
то чтобы пользователь образа не столкнулся с ошибками,
вы можете проверить запрошенную версию и запретить сборку или запуск контейнера.
Другая ситуация, вам нужна совместимость с разными версиями языка программирования, фреймворка или запускаемой программы,
вы можете проверить текущую версию и в процессе сборки или в запущенном контейнере подготовить необходимое окружение:

```shell
# Сборка образа с очень старой версией PHP
docker build \
   -t example-secrets \
   -f Dockerfile \
   --build-arg PHP_VERSION=5.6-apache \
   ./root

# Запуск контейнера завершится ошибкой из-за проверки на версию PHP
docker run --rm -ti --name secret_1 \
   -e MONGO_HOST=mongo \
   -e MONGO_USERNAME=user \
   -e MONGO_PASSWORD=123 \
   -e MONGO_DATABASE=demo \
   -p "80:80" \
   example-secrets
```

## Ссылки

* [Документация по встроенным классам для работы с MongoDB в PHP](https://www.php.net/manual/en/book.mongodb.php)
* [pypiserver](https://github.com/pypiserver/pypiserver)
* [Создать .htpasswd файл онлайн](https://hostingcanada.org/htpasswd-generator/)
* [htpasswd - Manage user files for basic authentication](https://httpd.apache.org/docs/current/programs/htpasswd.html)
* [Generating a new SSH key and adding it to the ssh-agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)
* [Adding a new SSH key to your GitHub account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)
