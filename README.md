# Шпаргалка по безопасности Docker

Список распространённых ошибок в сфере безопасности и рекомендаций по защите контейнеров Docker
от [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html).

## Вольный перевод с примерами и комментариями

* [Правило №0. Регулярно обновляйте хост и Docker](#правило-0-регулярно-обновляйте-хост-и-docker)
* [Правило №1. Не давайте доступ к сокету демона Docker (даже для контейнеров)](#правило-1-не-давайте-доступ-к-сокету-демона-docker-даже-для-контейнеров)
* [Правило №2. Указывайте пользователя](#правило-2-указывайте-пользователя)
* [Правило №3. Ограничьте возможности контейнера](#правило-3-ограничьте-возможности-контейнера)
* [Правило №4. Предотвращение повышения привилегий внутри контейнера](#правило-4-предотвращение-повышения-привилегий-внутри-контейнера)
* [Правило №5. Помните о возможности подключения между контейнерами](#правило-5-помните-о-возможности-подключения-между-контейнерами)
* [Правило №6. Используйте модуль безопасности Linux (seccomp, AppArmor или SELinux)](#правило-6-используйте-модуль-безопасности-linux-seccomp-apparmor-или-selinux)
* [Правило №7. Ограничьте ресурсы (память, процессор, файловые дескрипторы, процессы, перезапуски)](#правило-7-ограничьте-ресурсы-память-процессор-файловые-дескрипторы-процессы-перезапуски)
* [Правило №8. Используйте файловую систему и тома только для чтения](#правило-8-используйте-файловую-систему-и-тома-только-для-чтения)
* [Правило №9. Интегрируйте инструменты поиска уязвимостей контейнеров в CI/CD](#правило-9-интегрируйте-инструменты-поиска-уязвимостей-контейнеров-в-cicd)
* [Правило №10. Установите уровень ведения журнала демона Docker на info](#правило-10-установите-уровень-ведения-журнала-демона-docker-на-info)
* [Правило №11. Запускайте Docker в режиме без прав суперпользователя](#правило-11-запускайте-docker-в-режиме-без-прав-суперпользователя)
* [Правило №12. Используйте секреты Docker для управления конфиденциальными данными](#правило-12-используйте-секреты-docker-для-управления-конфиденциальными-данными)
* [Правило №13. Повышение безопасности цепочки распространения](#правило-13-повышение-безопасности-цепочки-распространения)

### Правило №0. Регулярно обновляйте хост и Docker



### Правило №1. Не давайте доступ к сокету демона Docker (даже для контейнеров)

Демон Docker использует сокет `/var/run/docker.sock`.
Это основная точка входа для Docker API.
Владельцем этого сокета является пользователь `root`.
Предоставление доступа к нему
равносильно предоставлению неограниченного доступа пользователю `root` на вашем хосте.

Не предоставляйте доступ к `/var/run/docker.sock` другим контейнерам.
Режим только для чтения не является решением проблемы.

Пример получения доступа к файловой системе хоста:

```shell
# Запускаем контейнер и монтируем сокет
docker run --rm -ti -v /var/run/docker.sock:/var/run/docker.sock debian:bookworm-slim

# Устанавливаем клиент Docker в контейнере
apt update && apt install -y wget \
    && mkdir -p /etc/apt/keyrings \
    && wget -O /etc/apt/keyrings/docker.asc https://download.docker.com/linux/debian/gpg \
    && echo "deb [signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian bookworm stable" > /etc/apt/sources.list.d/docker.list \
    && apt update && apt install -y docker-ce-cli

# Получаем доступ к файловой системе хоста из контейнера
docker run --rm -ti -v /:/mnt debian:bookworm-slim chroot /mnt bash
```

Не используйте TCP сокет демона Docker.

Если вы запускаете демон Docker как `dockerd -H fd:// -H tcp://0.0.0.0:2375`
или используете настройку в `/etc/docker/daemon.json`:

```json
{
   "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2375"]
}
```

вы предоставляете незашифрованный и неаутентифицированный прямой доступ к демону Docker.

Если хост подключен к Интернету, это означает, что демон Docker на вашем компьютере
может быть использован кем угодно из общедоступного Интернета.
Если вам нужен удаленный доступ, то следуйте рекомендациям из
[официальной документации](https://docs.docker.com/reference/cli/dockerd/#daemon-socket-option).

Возможно в хозяйстве пригодится [docker-socket-proxy](https://github.com/Tecnativa/docker-socket-proxy).

#### Почему некоторые образы нарушают это правило?

1. **[Portainer](https://docs.portainer.io/start/install-ce/server/docker/linux)**
   
   Веб-интерфейс для управления Docker-контейнерами.
   Ему нужен доступ к API Docker, чтобы управлять контейнерами, образами, сетями, томами и т.п.
   Без `/var/run/docker.sock` он не сможет взаимодействовать с Docker Engine.

2. **[Watchtower](https://containrrr.dev/watchtower/)**
   
   Этот инструмент следит за обновлениями образов и перезапускает контейнеры, если вышла новая версия.
   Без `/var/run/docker.sock` он не сможет обновлять образы и перезапускать контейнеры.
   Однако, авторы рекомендуют использовать этот инструмент **только**
   в домашних лабораториях, медиацентрах, в среде разработки и т.п.,
   и **не** использовать в производственной среде.

3. **[Docker-in-Docker (DinD)](https://hub.docker.com/_/docker)**
   
   В некоторых CI/CD сценариях (например, GitLab CI или GinHUb Actions) запускается Docker внутри контейнера.
   Для этого нужен доступ к Docker API хоста, чтобы запускать вложенные контейнеры.

### Правило №2. Указывайте пользователя

Настройка контейнера для использования непривилегированного пользователя - 
лучший способ предотвратить атаки с повышением привилегий.
Это можно сделать тремя разными способами:

1. Указать пользователя при старте контейнера, используя аргумент `-u`:
   ```shell
   docker run --rm -ti -u nobody debian:bookwork-slim
   ```

2. Использовать инструкцию `USER` в `Dockerfile`:
   ```dockerfile
   FROM debian:bookworm-slim

   RUN useradd -s /usr/sbin/nologin appuser
   
   USER appuser
   ```

3. Включить поддержку пользовательского пространства имен в демоне Docker
   `dockerd -H fd:// --userns-remap="default"` или в `/etc/docker/daemon.json`:
   ```json
   {
      "userns-remap": "default"
   }
   ```
   При включении этой опции контейнеры изолированы от пользователей хоста,
   а это значит, что вы никогда не пересечетесь с существующими на хосте UID/GID.
   Поэтому если в контейнер примонтирована директория с хоста, то у вас будут проблемы с правами.

   Дополнительную информацию можно найти в
   [официальной документации](https://docs.docker.com/engine/security/userns-remap/). 

### Правило №3. Ограничьте возможности контейнера

[Возможности ядра Linux](https://www.opennet.ru/man.shtml?topic=capabilities) - это набор привилегий,
которые могут использоваться _привилегированными_ пользователями.
Docker по умолчанию работает только с частью возможностей.
Вы можете изменить это и отказаться от некоторых возможностей (с помощью `--cap-drop`)
для повышения безопасности контейнеров Docker
или добавить некоторые возможности (с помощью `--cap-add`) при необходимости.
Не забывайте, что не следует запускать контейнеры с флагом `--privileged` - 
это добавит в контейнер **ВСЕ** возможности ядра Linux.

Самый безопасный способ - удалить все возможности `--cap-drop all` и добавить только необходимые:

```shell
docker run --rm -ti --cap-drop all --cap-add CHOWN debian:bookworm-slim
```

**И помните: не запускайте контейнеры с флагом --privileged!!!**

Однако в любом правиле есть исключения.
Существуют образы, работа которых не возможна без флага `--privileged`,
например [Docker-in-Docker (DinD)](https://hub.docker.com/_/docker).

В большинстве случаев можно обойтись без `--privileged`, заменяя его:

* `--cap-add=NET_ADMIN` - для сетевых настроек (контейнеры с VPN-серверами)
* `--cap-add=SYS_ADMIN` - для монтирования (контейнеры для работы с файловыми системами)
* `--device=/dev/xyz` - для USB/GPU (контейнеры для работы с Android)
* `--security-opt seccomp=unconfined` - для eBPF (Extended Berkeley Packet Filter)

### Правило №4. Предотвращение повышения привилегий внутри контейнера

Всегда запускайте образы Docker с `--security-opt=no-new-privileges`для предотвращения повышения привилегий.
Это не позволит контейнеру получить новые привилегии с помощью двоичных файлов `setuid` или `setgid`.

Я смог повысить привилегии обычного пользователя внутри контейнера с разрешенным `setuid`
только в двух случаях:

1. в образе существует файл с установленным setuid-битом и его владелец `root`:
   ```Dockerfile
   FROM debian:bookworm-slim

   RUN cp /bin/bash /bash && chmod u+s /bash
   ```
   Собираем образ и запускаем контейнер:
   ```shell 
   docker build -t test .
   docker run --rm -ti -u nobody test
   ```

2. смонтировать файл с установленным setuid-битом и владельцем `root` с хостовой ОС в контейнер:
   ```shell
   sudo cp /bin/bash .
   sudo chmod u+s /bash
   docker run --rm -ti -u nobody -v ./bash:/bash debian:bookworm-slim
   ```

Удостовериться, что текущий пользователь `nobody`, затем выполнить setuid-бинарник
и удостовериться, что текущий пользователь теперь `root`:

```shell
nobody@7ede7203e07c:/$ whoami 
nobody
nobody@7ede7203e07c:/$ ls -l bash 
-rwsr-xr-x 1 root root 1265648 Mar 10 18:23 bash
nobody@7ede7203e07c:/$ ./bash -p
bash-5.2# whoami 
root
```

Теперь то же самое, но с флагом `--security-opt=no-new-privileges`:

```shell
docker run --rm -ti -u nobody --security-opt=no-new-privileges test
```

Результат:

```shell
nobody@39efd9d69c06:/$ whoami 
nobody
nobody@39efd9d69c06:/$ ls -l bash 
-rwsr-xr-x 1 root root 1265648 Mar 10 18:23 bash
nobody@39efd9d69c06:/$ ./bash -p
nobody@39efd9d69c06:/$ whoami 
nobody
```

### Правило №5. Помните о возможности подключения между контейнерами

Межконтейнерная связь (icc) включена по умолчанию и позволяет всем контейнерам взаимодействовать друг с другом
через [мостовую сеть docker0](https://docs.docker.com/engine/network/drivers/bridge/#use-the-default-bridge-network).

Межконтейнерную связь можно отключить, если передать флаг `--icc=false` демону Docker - `dockerd -H fd:// -icc=false`
или используя настройку в `/etc/docker/daemon.json`:

```json
{
   "icc": false
}
```

Вместо полного отключения межконтейнерной связи,
рассмотрите возможность определения конкретных сетевых конфигураций.
Создавайте [пользовательские сети](https://docs.docker.com/engine/network/) Docker и указывайте,
какие контейнеры должны быть к ним подключены.
Этот метод обеспечивает более детальный контроль над взаимодействием контейнеров.

### Правило №6. Используйте модуль безопасности Linux (seccomp, AppArmor или SELinux)

Двоичный файл Docker генерирует [профиль](https://github.com/moby/moby/blob/master/profiles/apparmor/template.go)
с именем `docker-default` в `tmpfs`, загружает его в ядро и использует по умолчанию для запуска контейнеров:

```shell
# Такая команда
docker run --rm -ti hello-world
# превращается в такую
docker run --rm -ti --security-opt apparmor=docker-default hello-world
```

**Поэтому никогда не отключайте профиль безопасности по умолчанию!**

Рассмотрите возможность использования профиля безопасности, такого как
[seccomp](https://docs.docker.com/engine/security/seccomp/) или [AppArmor](https://docs.docker.com/engine/security/apparmor/).

### Правило №7. Ограничьте ресурсы (память, процессор, файловые дескрипторы, процессы, перезапуски)

Лучший способ избежать [DoS-атак](https://ru.wikipedia.org/wiki/DoS-атака) - ограничить ресурсы. Вы можете ограничить:

* **процессор** - `--cpus=<number>`
* **память** - `-m=<number><units>` или `--memory=<number><units>`
* **максимальное количество перезапусков** - `--restart=on-failure:<number_of_restarts>`
* **максимальное количество файловых дескрипторов** - `--ulimit nofile=<number>`
* **максимальное количество процессов** - `--ulimit nproc=<number>`

`top`, `htop` и аналогичные утилиты, запущенные внутри контейнера, отображают ресурсы хостовой системы.

### Правило №8. Используйте файловую систему и тома только для чтения

**Запускайте контейнеры с файловой системой только для чтения**, используя флаг `--read-only`:

```shell
# sh: 1: cannot create /tmp/somefile: Read-only file system
docker run --rm -ti --read-only debian:bookworm-slim \
    sh -c 'echo "sometext" > /tmp/somefile'
```

Если приложению внутри контейнера нужно что-то временно сохранить, используйте временную файловую систему:

```shell
docker run --rm -ti --read-only --tmpfs /tmp debian:bookworm-slim \
    sh -c 'echo "sometext" > /tmp/somefile'
```

Если контейнер активно записывает данные в `/tmp`, это может привести к **переполнению памяти**.
Поэтому стоит ограничить [размер](https://docs.docker.com/engine/storage/tmpfs/#options-for---tmpfs) `tmpfs`:

```shell
docker run --rm -ti --read-only --tmpfs /tmp:size=64m debian:bookworm-slim \
    sh -c 'echo "sometext" > /tmp/somefile'
```

Если приложению внутри контейнера нужно что-то сохранить перманентно, используйте тома или bind mounts:

```shell
# Использование тома с именем temp-volume
docker run --rm -ti --read-only -v temp-volume:/tmp debian:bookworm-slim sh -c 'echo "sometext" > /tmp/somefile'

# Использование bind mounts
mkdir ./tmp && chmod 1777 ./tmp
docker run --rm -ti --read-only -v ./tmp:/tmp debian:bookworm-slim sh -c 'echo "sometext" > /tmp/somefile'
```

Если вы монтируете том или директорию с хоста,
но запущенному внутри контейнера приложению нужна только операция чтения, то используйте режим только чтение:

```shell
docker run --rm -ti -p "80:80" -v wwwdata:/var/www:ro nginx:1.27-alpine3.21
```

### Правило №9. Интегрируйте инструменты сканирования контейнеров в CI/CD

Конвейеры CI/CD должны включать различные проверки безопасности,
такие как проверка синтаксиса, статический анализ кода и сканирование контейнеров.

Многих проблем можно избежать, если следовать рекомендациям при написании `Dockerfile`.
Добавление средства проверки безопасности в качестве этапа в процессе сборки может значительно облегчить жизнь.
Обычно проверяются следующие проблемы:

* указан пользователь в инструкции `USER`
* базовая версия образа зафиксирована
* версии пакетов ОС зафиксированы
* используется `COPY`, вместо `ADD` если это возможно
* в инструкциях `RUN` не используется `curl` 

Инструменты для сканирования контейнеров особенно важны для успешной реализации стратегии безопасности.
Они могут обнаруживать известные уязвимости, секреты и неправильные настройки в образах контейнеров
и предоставлять отчёт о результатах с рекомендациями по их устранению.

[Читать подробнее](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-9-integrate-container-scanning-tools-into-your-cicd-pipeline)

### Правило №10. Установите уровень ведения журнала демона Docker на info

Если в конфигурационном файле `/etc/docker/daemon.json` отсутствует параметр `log-level`,
и демон Docker не запущен с аргументом `--log-level`,
то используется уровень по умолчанию - `info`.

Базовый уровень ведения журнала `info` и выше будет регистрировать все события, кроме отладочных.
Если это не требуется, не запускайте демон Docker на уровне ведения журнала `debug`.

### Правило №11. Запускайте Docker в режиме без прав суперпользователя

Режим без прав суперпользователя гарантирует,
что демон Docker и контейнеры будут работать от имени непривилегированного пользователя.
Это означает, что даже если злоумышленник выйдет из контейнера,
у него не будет прав суперпользователя на хосте,
что, в свою очередь, существенно ограничивает возможности для атаки.
Это отличается от режима `userns-remap`, в котором демон по-прежнему работает с правами суперпользователя.

Оцените [конкретные требования](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)
и [уровень безопасности](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html) вашей среды,
чтобы определить, подходит ли вам режим без прав суперпользователя.
Для сред, в которых безопасность имеет первостепенное значение,
[а ограничения режима без прав суперпользователя](https://docs.docker.com/engine/security/rootless/#known-limitations)
не противоречат эксплуатационным требованиям,
настоятельно рекомендуется использовать эту конфигурацию.
В качестве альтернативы Docker можно использовать [Podman](https://podman.io/).

Режим без прав суперпользователя позволяет запускать демон Docker и контейнеры от имени пользователя,
не являющегося суперпользователем, чтобы снизить потенциальные уязвимости в демоне и среде выполнения контейнеров.
Режим без прав суперпользователя не требует прав суперпользователя даже во время установки демона Docker
при условии соблюдения предварительных требований.

#### Предварительные требования

* должен быть установлен `newuidmap` и `newgidmap` на хост-машине (пакет `uidmap` в большинстве дистрибутивов):
  ```shell
  sudo apt install -y uidmap
  ```

* `/etc/subuid` и `/etc/subgid` должны содержать не менее 65 536 подчиненных UID/GID для пользователя:
  ```shell
  grep ^$(whoami): /etc/subuid  # user:100000:65536
  grep ^$(whoami): /etc/subgid  # user:100000:65536
  ```

#### Предварительные требования для Debian GNU/Linux

* должен быть установлен пакет `dbus-user-session`:
  ```shell
  sudo apt install -y dbus-user-session
  ```
* для Debian 11 должен быть установлен пакет `fuse-overlayfs`:
  ```shell
  sudo apt install -y fuse-overlayfs
  ``` 
* версия `slirp4netns` выше `0.4.0`:
  ```shell
  slirp4netns --version
  
  # установить или обновить при необходимости
  wget -qO- https://api.github.com/repos/rootless-containers/slirp4netns/releases/latest | \
      awk -F'"' '/"browser_download_url"/ {print $(NF-1)}' | \
      grep "slirp4netns-$(uname -m)" | \
      wget -qO /usr/local/bin/slirp4netns -i- --show-progress && \
      chmod +x /usr/local/bin/slirp4netns
  ```

Подсказки для других дистрибутивов можно [найти тут](https://docs.docker.com/engine/security/rootless/#distribution-specific-hint).

#### Установка

Если общесистемный демон Docker запущен, то лучше остановить:

```shell
sudo systemctl disable --now docker.service docker.socket
sudo rm /var/run/docker.sock
```

Выполнять установку нужно от имени пользователя, не имеющего права доступа `root`:

```shell
# Если подключен репозиторий Docker
dockerd-rootless-setuptool.sh install

# Если скрипты не найдены, то установить пакет
sudo apt install -y docker-ce-rootless-extras

# Если репозиторий не подключен, установка с помощью скрипта
# (двоичные файлы будут установлены по адресу ~/bin)
wget -qO- https://get.docker.com/rootless | sh
```

#### Удаление

```shell
# Удаление сервиса
dockerd-rootless-setuptool.sh uninstall

# Удаление каталога данных
rootlesskit rm -rf ~/.local/share/docker

# Опционально, удалить двоичные файлы
sudo apt purge -y docker-ce-rootless-extras
# или если установка с помощью скрипта
cd ~/bin
rm -f containerd* ctr docker* rootlesskit* runc vpnkit
```

Больше информации в [официальной документации](https://docs.docker.com/engine/security/rootless/#usage).

### Правило №12. Используйте секреты Docker для управления конфиденциальными данными

[Секреты Docker](./12-secrets/README.md) обеспечивают безопасный способ хранения конфиденциальных данных,
таких как пароли, токены и SSH-ключи, и управления ими.
Использование секретов Docker помогает избежать раскрытия конфиденциальных данных
в образах контейнеров или в командах во время выполнения.

### Правило №13. Повышение безопасности цепочки распространения

Основываясь на принципах, изложенных в [правиле №9](#правило-9-интегрируйте-инструменты-сканирования-контейнеров-в-cicd),
текущее правило включает внедрение дополнительных мер для защиты всего жизненного цикла образов контейнеров -
от создания до развертывания. Некоторые ключевые моменты:

* [Происхождение образов](https://slsa.dev/spec/v1.0/provenance):
  документируйте источники и историю образов, чтобы обеспечить их отслеживаемость и целостность
* [Создайте SBOM](https://cyclonedx.org/guides/CycloneDX%20One%20Pager.pdf):
  Создайте спецификацию программного обеспечения (SBOM) для каждого изображения
  с подробным описанием всех компонентов, библиотек и зависимостей
  для обеспечения прозрачности и управления уязвимостями
* [Подписывайте образы](https://github.com/notaryproject/notary):
  Цифровая подпись образов для подтверждения их целостности и подлинности,
  обеспечивающая доверие к их безопасности
* [Доверенный реестр](https://snyk.io/learn/container-security/container-registry-security/):
  храните задокументированные, подписанные образы с их SBOM в безопасном реестре,
  который обеспечивает строгий контроль доступа и поддерживает управление метаданными
* [Безопасное развертывание](https://www.openpolicyagent.org/docs/latest/#overview):
  внедрите политики безопасного развёртывания,
  таких как валидация образов, обеспечение безопасности во время выполнения
  и непрерывный мониторинг для поддержания безопасности развернутых образов
