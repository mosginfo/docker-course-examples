# Harbor

- [Установка, конфигурация и запуск](#установка-конфигурация-и-запуск)
- [Минимальная настройка реестра](#минимальная-настройка-реестра)
  - [Добавляем обычного пользователя](#добавляем-обычного-пользователя)
  - [Добавляем реестры](#добавляем-реестры)
  - [Настройка кеширующего прокси](#настройка-кеширующего-прокси)
  - [Добавляем проекты](#добавляем-проекты)


[**Harbor**](https://goharbor.io/) - это реестр с открытым исходным кодом,
который защищает артефакты с помощью политик и контроля доступа на основе ролей,
проверяет образы на уязвимости и подписывает их как доверенные.

## Установка, конфигурация и запуск

Следующая команда установит последнюю версию Harbor в директорию `/opt`: 

```shell
sudo mkdir /opt/harbor

wget -qO- https://api.github.com/repos/goharbor/harbor/releases/latest |\
    awk -F'"' '/"browser_download_url"/ {print $(NF-1)}' |\
    grep offile |\
    wget -qO- -i- --show-progress |\
    sudo tar -xzvf - -C /opt
```

Если нужна конкретная версия, то используйте URL:

```
https://api.github.com/repos/goharbor/harbor/releases/tags/<TAG_NAME>
```

Переходим в директорию с распакованным Harbor
и переименовываем шаблон конфигурационного файла, убирая расширение `tmpl`:

```shell
cd /opt/harbor
sudo mv harbor.yml.tmpl harbor.yml
```

Открываем конфигурационный файл и изменяем значения для наиболее важных параметров:

* `hostname` - IP адрес или доменное имя, используется для входа в веб интерфейс и командах Docker
* `http` - Настройки для HTTP подключения
* `https` - Настройки для HTTPS подключения, пока закомментируем
* `harbor_admin_password` - Пароль администратора
* `database.password` - Пароль для пользователя `postgres`
* `data_volume` - Путь к директории, где будут сохранены данные Harbor
  По-умолчанию использует файловую систему, если нужно другое хранилище - читайте документацию

Я буду использовать IP адрес `192.168.88.185`, порт `80` по-умолчанию, без HTTPS,
а данные хранить в директории `/var/lib/harbor`.
Теперь можно запустить установочный скрипт:

```shell
sudo ./install.sh
```

В консоли будет предупреждение о том, что протокол HTTP будет признан устаревшим в будущих версиях.
Игнорируем данное предупреждение, доступ по HTTPS мы настроим позже:

```
WARNING:root:WARNING: HTTP protocol is insecure.
Harbor will deprecate http protocol in the future.
Please make sure to upgrade to https
```

Ждем некоторое время, пока Harbor проинициализирует все нужные сервисы.
Процесс инициализации можно отслеживать командой:

```shell
docker compose logs -f
```

Теперь можно открыть браузер и перейти по адресу, указанному в параметре `hostname`,
если изменили порт с `80`/`443`, то не забудьте указать его явно.
Выполните вход с пользователем `admin` и паролем, указанным в параметре `harbor_admin_password`:

![Стартовый экран](assets/start-screen.png)

## Минимальная настройка реестра

### Добавляем обычного пользователя

Переходим в `Users` и добавляем нового пользователя:

![Новый пользователь](assets/add-user.png)

Если сейчас попытаться аутентифицироваться в реестре, то вы получите ошибку:

```shell
# Error response from daemon: Get "https://192.168.88.185/v2/":
# dial tcp 192.168.88.185:443: connect: connection refused
sudo docker login -u kyzimaspb 192.168.88.185
```

Docker по-умолчанию используется HTTPS.
Чтобы заставить его использовать HTTP,
нужно добавить адрес реестра в список `insecure-registries` в файле `/etc/docker/daemon.json`.
Если такой файл не существует, его нужно создать:

```json
{
  "insecure-registries" : ["192.168.88.185"]
}
```

Перезапускаем демона Docker и если вы аутентифицируетесь с той же машины, где установлен Harbor,
то желательно перезапустить и его, т.к. у меня с ним были проблемы и часть служб отваливалась:

```shell
sudo systemctl restart docker
sudo docker compose down
sudo docker compose up -d
```

Теперь можно повторно выполнить аутентификацию в реестре,
если вы все сделали верно, то получите ответ `Login Succeeded`.

### Добавляем реестры

Скорее всего вы захотите использовать привычные образы из DockerHub или GitHub GHCR.
Переходим в `Registries` и добавляем новый реестр на примере DockerHub:

![Добавление реестра DockerHub](assets/add-dockerhub-registry.png)

Если вам нужно получать образы из частных репозиториев, то можно указать `Access ID` и `Access Secret`,
для DockerHub это имя пользователя и токен доступа,
который можно получить в настройках аккаунта, пункт `Personal access tokens`.

Для добавления GitHub GHCR повторите шаги, но выберите из выпадающего списка `GitHub GHCR`.

### Настройка кеширующего прокси

Проекты в Harbor можно разделить на две группы:

1. Проект, который хранит образы текущего реестра
2. Проект прокси-кеша, который кеширует загружаемые образы из целевого реестра

Прокси-кеш позволяет:

* сократить количество запросов к целевому реестру
* увеличить скорость загрузки образов за счет их наличия в кеше
* автоматически обновлять кеш если манифест изменился
* работать автономно, когда целевой реестр не доступен, но образ есть в кеше
* использовать сохраненную копию образа даже если он был удален из целевого реестра

Переходим в `Projects` и создаем новый проект с именем `dockerhub`
с включенным прокси-кешем для ранее добавленного реестра `Docker Hub`.
По желанию можно сделать проект публичным:

![Прокси-кеш для DockerHub](assets/add-dockerhub-proxy-cache.png)

Если открыть только что созданный проект, то он не будет содержать ни одного образа:

![Пустой прокси-кеш](assets/empty-proxy-cache.png)

Выполним загрузку образа `debian:bookworm-slim` используя наш прокси-кеш.
Это официальный образ, который можно загружать не указываю пространство имен,
поэтому имя образа для загрузки будет иметь вид: `адрес_реестра_harbor/имя_проекта/имя_образа:тег`:

```shell
docker pull 192.168.88.185/dockerhub/debian:bookworm-slim
```

Если открыть проект `dockerhub`, то мы увидим загруженный образ:

![Debian в кеше](assets/debian-bookworm.png)

Выполним загрузку образа `kyzimaspb/gui:bookworm-slim` используя наш прокси-кеш.
Это пользовательский образ, поэтому необходимо указать пространство имен.
Имя образа для загрузки будет иметь вид: `адрес_реестра_harbor/имя_проекта/имя_пользователя/имя_образа:тег`:

```shell
docker pull 192.168.88.185/dockerhub/kyzimaspb/gui:bookworm-slim
```

Если открыть проект `dockerhub`, то мы увидим загруженный образ:

![GUI в кеше](assets/gui-bookworm-slim.png)

### Добавляем проекты

Я бы сравнил проекты с пространствами имен в реестре DockerHub.
Поэтому создадим проект с именем пользователя.
Переходим в `Projects` и создаем новый проект с именем `kyzimaspb`:

![Создание нового проекта](assets/add-project.png)

Открываем только что созданный проект и переходим во вкладку `Members`.
Добавляем пользователя в проект, можно выбрать любую подходящую роль,
в моем случае это `Maintainer`:

![Добавление пользователя в проект](assets/add-member.png)

Соберем тестовый образ и загрузим его в проект `kyzimaspb`:

```bash
docker build -t 192.168.88.185/kyzimaspb/hello - <<EOF
FROM 192.168.88.185/dockerhub/debian:bookworm-slim
CMD ["echo", "Hello, Docker!"]
EOF

# Просмотр образов из реестра Harbor
# Образ 192.168.88.185/kyzimaspb/hello с тегом latest должен появиться в списке
docker images | grep 192.168.88.185

docker push 192.168.88.185/kyzimaspb/hello
```

Теперь если перейти на вкладку `Repositories` проекта `kyzimaspb`,
то вы должны увидеть только что загруженный образ:

![Тестовый образ](assets/hello-image.png)

